#' Wrapper for running beagle to impute vcf
#'
#' @param gt path to .vcf.gz file.
#' @param out output prefix, output file will be `prefix.vcf.gz`.
#' @param nthreads number of threads beagle can use.
#'
#' @export
beagle_wrapper <- function(gt, out, nthreads = parallel::detectCores(), seed = 12345) {
  system2("beagle", args = c(
    sprintf("gt=%s", gt),
    sprintf("out=%s", out),
    sprintf("nthreads=%d", nthreads),
    sprintf("seed=%d", seed)
  ))
}


#' Convert vcf df to haplotype matrix
#'
#' Row is haplotype, column is variant.
#' @param vcf vcf data.frame or tibble.
#'
#' @export
vcf_to_hap_mat <- function(vcf) {
  if (length(vcf) < 10) {
    stop("No genotype in vcf, stop.")
  } else if (length(grep("/", vcf[10:ncol(vcf)])) > 0) {
    stop("vcf not phased, stop.")
  }

  # Split haplotype by `|`, into two matrix.
  # And transpose, row is sample, column is variant.
  hap1 <- sub("([^|]+)\\|([^|]+)", "\\1", vcf_to_gt_mat(vcf)) |> t()
  hap2 <- sub("([^|]+)\\|([^|]+)", "\\2", vcf_to_gt_mat(vcf)) |> t()

  # Add suffix to sample names.
  rownames(hap1) <- paste(rownames(hap1), "1", sep = ".")
  rownames(hap2) <- paste(rownames(hap2), "2", sep = ".")

  # Combine two matrix interleaving.
  hap_mat <- matrix(nrow = nrow(hap1) * 2, ncol = ncol(hap1))
  hap_mat[seq(1, nrow(hap_mat), by = 2), ] <- hap1
  hap_mat[seq(2, nrow(hap_mat), by = 2), ] <- hap2

  # Add rownames interleaving.
  rownames(hap_mat) <- character(nrow(hap_mat))
  rownames(hap_mat)[seq(1, nrow(hap_mat), by = 2)] <- rownames(hap1)
  rownames(hap_mat)[seq(2, nrow(hap_mat), by = 2)] <- rownames(hap2)
  colnames(hap_mat) <- colnames(hap1)

  return(hap_mat)
}

#' Count haplotypes per group
#'
#' @param hap_mat haplotype matrix produced by `vcf_to_hap_mat`.
#' @param group_info a named vector or factor that indicates each haplotype's group.
#'
#' @export
hap_mat_to_hap_long <- function(hap_mat, group_info) {
  colnames(hap_mat) <- paste("Pos", colnames(hap_mat), sep = ".")
  hap_long <- cbind(
    data.frame(
      SampleID = sub("(.*)\\.[12]$", "\\1", rownames(hap_mat)),
      HapID = rownames(hap_mat)
    ),
    hap_mat
  )

  if (class(group_info) == "factor") {
    for (group in levels(group_info)) {
      hap_long[[sprintf("Group.%s", group)]] <- group_info[hap_long$SampleID] == group
    }
  } else {
    for (group in unique(group_info)) {
      hap_long[[sprintf("Group.%s", group)]] <- group_info[hap_long$SampleID] == group
    }
  }

  return(hap_long)
}

#' Convert hap_long to hap_wide
#'
#' @param hap_long generated by hap_mat_to_hap_long.
#'
#' @export
hap_long_to_hap_wide <- function(hap_long) {
  # Paste Pos. columns to Seq column.
  pos_columns <- grep("Pos.", names(hap_long))
  hap_long$Seq <- apply(hap_long[pos_columns], 1, paste, collapse = "")

  splitted <- split(hap_long, hap_long$Seq)
  splitted <- splitted[order(sapply(splitted, nrow), decreasing = TRUE)]
  hap_wide <- lapply(splitted, function(x) {
    cbind(
      data.frame(
        Samples = unique(x$SampleID) |> paste(collapse = ","),
        Haps = paste(x$HapID, collapse = ", "),
        Seq = unique(x$Seq),
        Count = nrow(x)
      ),
      x[grep("Group.", names(x))] |> lapply(sum, na.rm = TRUE) |> as.data.frame()
    )
  }) |>
    do.call(rbind, args = _)

  hap_wide <- cbind(ID = sprintf("Hap%d", seq_len(nrow(hap_wide))), hap_wide)
  rownames(hap_wide) <- NULL

  # Save pos to attr.
  attr(hap_wide, "pos") <- sub("Pos.", "", names(hap_long)[pos_columns]) |>
    as.integer()

  return(hap_wide)
}

#' After filtering hap_wide, remove consensus bases in Seq.
#'
#' @param hap_wide_subset a subset of hap_wide (require "pos" attribute retained).
#'
#' @export
hap_wide_remove_consensus <- function(hap_wide_subset) {
  if (is.null(attr(hap_wide_subset, "pos"))) {
    stop(paste(
      c(
        'attr(hap_wide_subset, "pos") not found, please retain it during subset',
        "(e.g. use hap_wide[hap_wide$Count > 10,] rather then subset(hap_wide, Count > 10))."
      ),
      sep = "\n"
    ))
  }
  hap_mat <- strsplit(hap_wide_subset$Seq, "") |> do.call(rbind, args = _)
  colnames(hap_mat) <- attr(hap_wide_subset, "pos")
  hap_mat <- hap_mat[, apply(hap_mat, 2, function(x) length(unique(x))) > 1]

  new_hap_wide <- hap_wide_subset
  new_hap_wide$Seq <- apply(hap_mat, 1, paste, collapse = "")
  return(new_hap_wide)
}

#' Write hap_wide df to nexus file.
#'
#' @param hap_wide a hap_wide object.
#'
#' @param out Path to output file.
#'
#' @export
#'
write_nexus <- function(hap_wide, out) {
  trait_cols <- grep("Group.", names(hap_wide))

  ntax <- nrow(hap_wide)
  taxlabels <- paste(hap_wide$ID, collapse = "\n")
  nchar_ <- nchar(hap_wide$Seq[[1]])
  seq_matrix <- sprintf("%s %s", hap_wide$ID, hap_wide$Seq) |> paste(collapse = "\n")
  ntraits <- length(trait_cols)
  trait_labels <- paste(names(hap_wide)[trait_cols], collapse = " ")
  trait_matrix <- paste(
    sprintf("%s %s", hap_wide$ID, apply(hap_wide[trait_cols], 1, paste, collapse = ",")),
    collapse = "\n"
  )
  nexus_string <- glue::glue(
    "#NEXUS
BEGIN TAXA;
DIMENSIONS NTAX={ntax};
TAXLABELS
{taxlabels}
;
END;

BEGIN CHARACTERS;
DIMENSIONS NCHAR={nchar_};
FORMAT DATATYPE=DNA MISSING=? GAP=- ;
MATRIX
{seq_matrix}
;
END;

BEGIN TRAITS;
Dimensions NTRAITS={ntraits};
Format labels=yes missing=? separator=Comma;
TraitLabels {trait_labels};
Matrix
{trait_matrix}
;
END;
"
  )
  write(nexus_string, out)
}
