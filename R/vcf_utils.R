#' Read VCF file as tibble.
#' @param vcf_path Path to VCF file.
#' @export
setGeneric(
  "read_vcf",
  function(vcf_path, chromosome, start, end) {
    standardGeneric("read_vcf")
  }
)


setMethod(
  "read_vcf",
  signature(
    vcf_path = "character",
    chromosome = "missing",
    start = "missing",
    end = "missing"
  ),
  function(vcf_path) {
    con <- file(vcf_path, "r")
    header <- list()
    while (length(line <- readLines(con, n = 1)) > 0) {
      if (grepl("^##", line)) {
        header[[length(header) + 1]] <- line
      } else {
        break
      }
    }
    close(con)

    vcf <- readr::read_tsv(
      file = vcf_path,
      comment = "##",
      col_types = readr::cols(
        POS = readr::col_integer(),
        .default = readr::col_character()
      )
    )

    attr(vcf, "header") <- header

    return(vcf)
  }
)


setMethod(
  "read_vcf",
  signature(
    vcf_path = "character",
    chromosome = "character",
    start = "numeric",
    end = "numeric"
  ),
  function(vcf_path, chromosome, start, end) {
    if (!file.exists(paste0(vcf_path, ".tbi"))) {
      system2("tabix", args = vcf_path)
    }

    tmp_vcf <- tempfile(fileext = ".vcf")
    system2("tabix",
      args = c("-h", vcf_path, sprintf("%s:%d-%d", chromosome, start, end)),
      stdout = tmp_vcf
    )
    vcf <- read_vcf(tmp_vcf)
    unlink(tmp_vcf)
    return(vcf)
  }
)


#' Write VCF tibble as bgzipped file.
#' @param vcf A VCF tibble.
#' @param file Path to output bgzipped file.
#' @importFrom readr write_lines write_tsv
#' @export
write_vcf_bgzip <- function(vcf, file) {
  tmp_vcf <- tempfile(fileext = ".vcf")

  readr::write_lines(attr(vcf, "header"), tmp_vcf)
  readr::write_tsv(vcf, tmp_vcf, append = TRUE, col_names = TRUE)

  system2("bgzip", stdin = tmp_vcf, stdout = file)

  unlink(tmp_vcf)
}

# To remove fields after GT field in vcf sample columns (sep by `:`).
get_gt <- function(x) {
  sub("([^:]+).*", "\\1", x)
}


#' Get field matrix from vcf tibble.
#'
#' Get genotype field sample columns of vcf tibble, such as AD, DP...
#'
#' @param vcf a vcf tibble.
#' @param field field name, e.g. "AD", "DP"
#' @param mc.cores number of cores used in parallel::mclapply
#'
#' @export
vcf_to_field_matrix <- function(vcf, field, mc.cores = NULL) {
  format <- unique(vcf$FORMAT)

  if (length(format) != 1) {
    stop(sprintf("Inconsistent FORMAT: %s", paste(format, collapse = ", ")))
  }

  field_num <- which(strsplit(format, ":")[[1]] == field)

  format_col_num <- which(names(vcf) == "FORMAT")

  pattern <- paste0(paste(rep("([^:]+)", field_num), collapse = ":"), ".*")
  replacement <- paste0("\\", as.character(field_num))
  fun <- function(x) sub(pattern, replacement, vcf[[x]])
  sample_names <- names(vcf)[(format_col_num + 1):ncol(vcf)]

  if (is.null(mc.cores)) {
    field_mat <- lapply(sample_names, fun) |> do.call(cbind, args = _)
  } else {
    field_mat <- parallel::mclapply(sample_names, fun, mc.cores = mc.cores) |> do.call(cbind, args = _)
  }

  colnames(field_mat) <- sample_names

  return(field_mat)
}

#' Parse AD string matrix to a 3D array.
#'
#' @param ad_string_mat a matrix generated by `vcf_to_field_matrix(vcf, "AD")`.
#'
#' @export
ad_string_mat_to_ad_3d_array <- function(ad_string_mat, mc.cores = NULL) {
  if ("data.frame" %in% class(ad_string_mat)) {
    ad_string_mat <- as.matrix(ad_string_mat)
  }

  layer_number <- max(stringr::str_count(ad_string_mat[, 1], ",")) + 1

  ad_3d_array <- array(dim = c(nrow(ad_string_mat), ncol(ad_string_mat), layer_number))

  for (i in seq_len(layer_number)) {
    pattern <- paste0(paste(rep("([^,]+)", i), collapse = ","), ".*")
    replacement <- paste0("\\", as.character(i))
    fun <- function(j) {
      x <- sub(pattern, replacement, ad_string_mat[, j])
      x[grepl(",", x)] <- NA
      x <- as.integer(x)
      return(x)
    }
    if (is.null(mc.cores)) {
      ad_3d_array[, , i] <- lapply(seq_len(ncol(ad_string_mat)), fun) |> do.call(cbind, args = _)
    } else {
      ad_3d_array[, , i] <- parallel::mclapply(seq_len(ncol(ad_string_mat)), fun, mc.cores = mc.cores) |> do.call(cbind, args = _)
    }
  }

  dimnames(ad_3d_array) <- list(NULL, colnames(ad_string_mat), NULL)

  return(ad_3d_array)
}

#' Get DP matrix from AD 3D array.
#' @export
ad_3d_array_to_dp_mat <- function(ad_3d_array) {
  dp_mat <- rowSums(ad_3d_array, na.rm = TRUE, dims = 2)
  colnames(dp_mat) <- dimnames(ad_3d_array)[[2]]
  return(dp_mat)
}

#' Get SNP-Index matrix from AD 3D array.
#' @export
ad_3d_array_to_snp_index_mat <- function(ad_3d_array) {
  dp_mat <- ad_3d_array_to_dp_mat(ad_3d_array)
  snp_index_mat <- matrix(ad_3d_array[, , -1], nrow = dim(ad_3d_array)[1] * dim(ad_3d_array)[2], ncol = dim(ad_3d_array)[3] - 1) |>
    matrixStats::rowMaxs(na.rm = TRUE) |>
    matrix(nrow = dim(ad_3d_array)[1], ncol = dim(ad_3d_array)[2]) / dp_mat
  snp_index_mat[is.na(snp_index_mat)] <- 0
  snp_index_mat <- as.matrix(snp_index_mat)
  colnames(snp_index_mat) <- dimnames(ad_3d_array)[[2]]
  return(snp_index_mat)
}


#' Get genotype character matrix from vcf tibble.
#' @param vcf_df vcf tibble or data.frame.
#' @param simplify e.g. "T/T" > "T", "AG/AG" > "AG", won't simplify heterozygote.
#' @export
vcf_to_gt_mat <- function(vcf_df, simplify = FALSE) {
  # Empty matrix.
  gt_mat <- matrix(nrow = nrow(vcf_df), ncol = ncol(vcf_df) - 9)
  colnames(gt_mat) <- names(vcf_df)[10:length(vcf_df)]
  rownames(gt_mat) <- vcf_df$POS

  # Add to matrix row by row.
  for (i in seq_len(nrow(vcf_df))) {
    ref_alt <- c(vcf_df$REF[i], strsplit(vcf_df$ALT[i], ",")[[1]])
    names(ref_alt) <- 0:(length(ref_alt) - 1)

    gt <- vcf_df[i, 10:length(vcf_df)] |>
      unlist() |>
      get_gt()

    for (num in names(ref_alt)) {
      gt <- gsub(num, ref_alt[num], gt)
    }

    if (simplify == TRUE) {
      gt <- gsub("([^/|]+)[/|]\\1$", "\\1", gt) # e.g. "T/T" > "T", "A/T" > "A/T"
    }

    gt_mat[i, ] <- gt
  }

  return(gt_mat)
}

#' Calculate MAF and Missing rate of variants in vcf df
#' inside R
#'
#' @param vcf a vcf tibble.
#'
#' @export
vcf_variant_stats_R <- function(vcf) {
  missing_list <- list()
  maf_list <- list()

  m <- as.matrix(vcf[10:length(vcf)])
  allele_mat <- cbind(
    sub("([^/|]+)[/|]([^:])+.*", "\\1", m),
    sub("([^/|]+)[/|]([^:])+.*", "\\2", m)
  )

  tab_list <- apply(allele_mat, 1, table, simplify = FALSE)

  for (i in seq_len(length(tab_list))) {
    t <- tab_list[[i]]
    if ("." %in% names(t)) {
      missing_list[[length(missing_list) + 1]] <- t[names(t) == "."] / sum(t)
    } else {
      missing_list[[length(missing_list) + 1]] <- 0
    }
    maf_list[[length(maf_list) + 1]] <- t[names(t) != "."][2] / sum(t[names(t) != "."])
  }

  out <- cbind(
    vcf[1:2],
    Missing = unlist(missing_list),
    MAF = unlist(maf_list)
  )

  return(out)
}


bcftools_fill_tags_wrapper <- function(input, output, tags = "MAF,F_MISSING") {
  system2("bcftools", args = c("+fill-tags", input, "-Oz", "-o", output, "--", "-t", tags))
}


#' Calculate MAF and Missing rate of variants in vcf df
#' using bcftools +fill-tags
#'
#' @param vcf a vcf tibble or vcf file path.
#'
#' @export
setGeneric("bcftools_variant_stats", function(vcf) {
  standardGeneric("bcftools_variant_stats")
})

setMethod(
  "bcftools_variant_stats",
  signature(vcf = "character"),
  function(vcf) {
    # Missing contig in header (e.g. `##contig=<ID=1,length=43269907>`)
    # will cause bcftools stop, tabix is workaround
    if (!file.exists(paste0(vcf, ".tbi"))) {
      system2("tabix", vcf)
    }

    tmp_vcf_gz <- file.path(tempdir(), "bcftools_variant_stats.vcf.gz")
    bcftools_fill_tags_wrapper(vcf, tmp_vcf_gz)
    new_vcf <- read_vcf(tmp_vcf_gz)
    unlink(tmp_vcf_gz)

    info_mat <- strsplit(new_vcf$INFO, ";") |> do.call(rbind, args = _)
    out <- cbind(
      new_vcf[1:2],
      Missing = info_mat[grepl("F_MISSING", info_mat)] |>
        sub("[^=]+=(.*)", "\\1", x = _) |>
        as.numeric(),
      MAF = info_mat[grepl("MAF", info_mat)] |>
        sub("[^=]+=(.*)", "\\1", x = _) |>
        as.numeric()
    )
    return(out)
  }
)

setMethod(
  "bcftools_variant_stats",
  signature(vcf = "tbl_df"),
  function(vcf) {
    tmp_vcf_gz <- tempfile(fileext = ".vcf.gz")
    write_vcf_bgzip(vcf, tmp_vcf_gz)
    out <- bcftools_variant_stats(tmp_vcf_gz)
    unlink(tmp_vcf_gz)
    return(out)
  }
)

#' @export
vcftools_filter_wrapper <- function(input, output, maf = NULL, max_missing = NULL, biallelic = FALSE) {
  args <- c("--gzvcf", input, "--recode", "--stdout")

  if (!is.null(maf)) {
    args <- c("--maf", maf, args)
  }
  if (!is.null(max_missing)) {
    args <- c("--max-missing", max_missing, args)
  }
  if (biallelic) {
    args <- c("--min-alleles", "2", "--max-alleles", "2", args)
  }
  system2("vcftools", args, stdout = output)
}

#' @export
filter_csq <- function(x, variant_type_list) {
  x <- sub("CSQ=", "", x)
  x <- gsub(",", "\n", x)
  pattern <- paste0("(?m)^(?!.*(", paste(unlist(variant_type_list), collapse="|"), ").*).*\\n?")
  x <- gsub(pattern, "", x, perl=TRUE)
  x <- gsub("\n", ",", x)
  x <- trimws(x)
  return(x)
}

#' @export
sub_gene_with_gene_anno <- function(info, pattern, gene_to_anno) {

  info_list <- as.list(info)

  gene_id_list <- stringr::str_extract_all(info, pattern)
  gene_anno_list <- lapply(gene_id_list, function(x) gene_to_anno[x])

  for (i in seq_len(length(gene_id_list))) {
    for (j in seq_len(length(gene_id_list[[i]]))) {
      info_list[[i]] <- sub(gene_id_list[[i]][[j]], gene_anno_list[[i]][[j]], info_list[[i]])
    }
  }
  return(unlist(info_list))
}
