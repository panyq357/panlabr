#' Read VCF file as tibble.
#' @param vcf_path Path to VCF file.
#' @export
setGeneric(
  "read_vcf",
  function(vcf_path, chromosome, start, end) {
    standardGeneric("read_vcf")
  }
)


setMethod(
  "read_vcf",
  signature(
    vcf_path = "character",
    chromosome = "missing",
    start = "missing",
    end = "missing"
  ),
  function(vcf_path) {
    header <- readr::read_lines(vcf_path)
    header <- header[1:(grep("#CHROM", header) - 1)]

    vcf <- readr::read_tsv(
      file = vcf_path,
      comment = "##",
      col_types = readr::cols(
        POS = readr::col_integer(),
        .default = readr::col_character()
      )
    )

    attr(vcf, "header") <- header

    return(vcf)
  }
)


setMethod(
  "read_vcf",
  signature(
    vcf_path = "character",
    chromosome = "character",
    start = "numeric",
    end = "numeric"
  ),
  function(vcf_path, chromosome, start, end) {
    if (!file.exists(paste0(vcf_path, ".tbi"))) {
      system2("tabix", args = vcf_path)
    }

    tmp_vcf <- tempfile(fileext = ".vcf")
    system2("tabix",
      args = c("-h", vcf_path, sprintf("%s:%d-%d", chromosome, start, end)),
      stdout = tmp_vcf
    )
    vcf <- read_vcf(tmp_vcf)
    unlink(tmp_vcf)
    return(vcf)
  }
)


#' Write VCF tibble as bgzipped file.
#' @param vcf A VCF tibble.
#' @param file Path to output bgzipped file.
#' @importFrom readr write_lines write_tsv
#' @export
write_vcf_bgzip <- function(vcf, file) {
  tmp_vcf <- tempfile(fileext = ".vcf")

  readr::write_lines(attr(vcf, "header"), tmp_vcf)
  readr::write_tsv(vcf, tmp_vcf, append = TRUE, col_names = TRUE)

  system2("bgzip", stdin = tmp_vcf, stdout = file)

  unlink(tmp_vcf)
}

# To remove fields after GT field in vcf sample columns (sep by `:`).
get_gt <- function(x) {
  sub("([^:]+).*", "\\1", x)
}


#' Get field matrix from vcf tibble.
#'
#' Get genotype field sample columns of vcf tibble, such as AD, DP...
#'
#' @param vcf a vcf tibble.
#' @param field field name, e.g. "AD", "DP"
#'
#' @export
vcf_to_field_matrix <- function(vcf, field) {

  format <- unique(vcf$FORMAT)

  if (length(format) != 1) { stop(sprintf("Inconsistent FORMAT: %s", paste(format, collapse=", "))) }

  field_num <- which(strsplit(format, ":")[[1]] == field)

  format_col_num <- which(names(vcf) == "FORMAT")

  field_mat <- matrix(nrow=nrow(vcf), ncol=length(vcf) - format_col_num)

  for (i in seq_len(ncol(field_mat))) {
    field_mat[, i] <- sub(
      paste0(paste(rep("([^:]+)", field_num), collapse=":"), ".*"),
      paste0("\\", as.character(field_num)),
      vcf[[format_col_num+i]]
    )
  }

  colnames(field_mat) <- sprintf("%s.%s", names(vcf)[(format_col_num+1):length(vcf)], field)
  return(field_mat)
}

#' Parse AD string matrix to a 3D Array.
#'
#' @param ad_string_mat a matrix generated by `vcf_to_field_matrix(vcf, "AD")`.
#'
#' @export
ad_string_mat_to_ad_3d_array <- function(ad_string_mat) {

  if ("data.frame" %in% class(ad_string_mat)) {
    ad_string_mat <- as.matrix(ad_string_mat)
  }

  comma_number <- stringr::str_count(ad_string_mat[, 1], ",")

  ad_3d_array <- array(dim = c(nrow(ad_string_mat), ncol(ad_string_mat), max(comma_number)+1))

  for (i in 1:(max(comma_number)+1)) {
    layer <- sub(
      paste0(paste(rep("([^,]+)", i), collapse=","), ".*"),
      paste0("\\", as.character(i)),
      ad_string_mat
    )
    layer[as.matrix(grepl(",", layer), nrow=nrow(layer), ncol=ncol(layer))] <- NA
    mode(layer) <- "integer"
    ad_3d_array[, , i] <- layer
  }
  return(ad_3d_array)
}


#' Get genotype character matrix from vcf tibble.
#' @param vcf_df vcf tibble or data.frame.
#' @param simplify e.g. "T/T" > "T", "AG/AG" > "AG", won't simplify heterozygote.
#' @export
vcf_to_gt_mat <- function(vcf_df, simplify = FALSE) {
  # Empty matrix.
  gt_mat <- matrix(nrow = nrow(vcf_df), ncol = ncol(vcf_df) - 9)
  colnames(gt_mat) <- names(vcf_df)[10:length(vcf_df)]
  rownames(gt_mat) <- vcf_df$POS

  # Add to matrix row by row.
  for (i in seq_len(nrow(vcf_df))) {
    ref_alt <- c(vcf_df$REF[i], strsplit(vcf_df$ALT[i], ",")[[1]])
    names(ref_alt) <- 0:(length(ref_alt) - 1)

    gt <- vcf_df[i, 10:length(vcf_df)] |>
      unlist() |>
      get_gt()

    for (num in names(ref_alt)) {
      gt <- gsub(num, ref_alt[num], gt)
    }

    if (simplify == TRUE) {
      gt <- gsub("([^/|]+)[/|]\\1$", "\\1", gt) # e.g. "T/T" > "T", "A/T" > "A/T"
    }

    gt_mat[i, ] <- gt
  }

  return(gt_mat)
}

#' Calculate MAF and Missing rate of variants in vcf df
#' inside R
#'
#' @param vcf a vcf tibble.
#'
#' @export
vcf_variant_stats_R <- function(vcf) {
  missing_list <- list()
  maf_list <- list()

  m <- as.matrix(vcf[10:length(vcf)])
  allele_mat <- cbind(
    sub("([^/|]+)[/|]([^:])+.*", "\\1", m),
    sub("([^/|]+)[/|]([^:])+.*", "\\2", m)
  )

  tab_list <- apply(allele_mat, 1, table, simplify = FALSE)

  for (i in seq_len(length(tab_list))) {
    t <- tab_list[[i]]
    if ("." %in% names(t)) {
      missing_list[[length(missing_list) + 1]] <- t[names(t) == "."] / sum(t)
    } else {
      missing_list[[length(missing_list) + 1]] <- 0
    }
    maf_list[[length(maf_list) + 1]] <- t[names(t) != "."][2] / sum(t[names(t) != "."])
  }

  out <- cbind(
    vcf[1:2],
    Missing = unlist(missing_list),
    MAF = unlist(maf_list)
  )

  return(out)
}


bcftools_fill_tags_wrapper <- function(input, output, tags = "MAF,F_MISSING") {
  system2("bcftools", args = c("+fill-tags", input, "-Oz", "-o", output, "--", "-t", tags))
}


#' Calculate MAF and Missing rate of variants in vcf df
#' using bcftools +fill-tags
#'
#' @param vcf a vcf tibble or vcf file path.
#'
#' @export
setGeneric("bcftools_variant_stats", function(vcf) {
  standardGeneric("bcftools_variant_stats")
})

setMethod(
  "bcftools_variant_stats",
  signature(vcf = "character"),
  function(vcf) {
    # Missing contig in header (e.g. `##contig=<ID=1,length=43269907>`)
    # will cause bcftools stop, tabix is workaround
    if (!file.exists(paste0(vcf, ".tbi"))) {
      system2("tabix", vcf)
    }

    tmp_vcf_gz <- file.path(tempdir(), "bcftools_variant_stats.vcf.gz")
    bcftools_fill_tags_wrapper(vcf, tmp_vcf_gz)
    new_vcf <- read_vcf(tmp_vcf_gz)
    unlink(tmp_vcf_gz)

    info_mat <- strsplit(new_vcf$INFO, ";") |> do.call(rbind, args = _)
    out <- cbind(
      new_vcf[1:2],
      Missing = info_mat[grepl("F_MISSING", info_mat)] |>
        sub("[^=]+=(.*)", "\\1", x = _) |>
        as.numeric(),
      MAF = info_mat[grepl("MAF", info_mat)] |>
        sub("[^=]+=(.*)", "\\1", x = _) |>
        as.numeric()
    )
    return(out)
  }
)

setMethod(
  "bcftools_variant_stats",
  signature(vcf = "tbl_df"),
  function(vcf) {
    tmp_vcf_gz <- tempfile(fileext = ".vcf.gz")
    write_vcf_bgzip(vcf, tmp_vcf_gz)
    out <- bcftools_variant_stats(tmp_vcf_gz)
    unlink(tmp_vcf_gz)
    return(out)
  }
)

#' @export
vcftools_filter_wrapper <- function(input, output, maf = NULL, max_missing = NULL, biallelic = FALSE) {
  args <- c("--gzvcf", input, "--recode", "--stdout")

  if (!is.null(maf)) {
    args <- c("--maf", maf, args)
  }
  if (!is.null(max_missing)) {
    args <- c("--max-missing", max_missing, args)
  }
  if (biallelic) {
    args <- c("--min-alleles", "2", "--max-alleles", "2", args)
  }
  system2("vcftools", args, stdout=output)
}
